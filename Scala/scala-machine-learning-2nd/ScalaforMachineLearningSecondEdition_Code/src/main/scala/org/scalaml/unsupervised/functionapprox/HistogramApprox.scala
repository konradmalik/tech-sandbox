/**
 * Copyright (c) 2013-2017  Patrick Nicolas - Scala for Machine Learning - All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * The source code in this file is provided by the author for the sole purpose of illustrating the
 * concepts and algorithms presented in "Scala for Machine Learning 2nd edition".
 * ISBN: 978-1-783355-874-2 Packt Publishing.
 *
 * Version 0.99.2
 */
package org.scalaml.unsupervised.functionapprox

import org.scalaml.Predef.Context.ToDouble

import scala.collection._

/**
 * Histogram for function approximation. A weighted average can be provided to
 * smooth the predictive values, in the case some bins have no entry (alternative
 * to further expansion of bins)
 *
 * There is no assumption made regarding
 * - size of input data (the input data can be infinite stream)
 * - range of input data
 * - the underlying model is continous
 * - the Input data is ordered or is a time series
 * @author Patrick Nicolas
 * @param numBins Number of bins
 * @param input Input multi-dimension data of type T with a value of y
 * @author Patrick Nicolas
 * @since 0.99.2 Jan 11, 2017
 * @version 0.99.2
 */
@throws(classOf[IllegalArgumentException])
final private[scalaml] class HistogramApprox[T: ToDouble](
    numBins: Int,
    input: Array[(T, Double)]
) extends FunctionApprox[T] {
  import HistogramApprox._
  require(input.size > numBins, "Number of bins exceeds the size of data")

  private[this] val (min, max) = input./:((Double.MaxValue, -Double.MaxValue)) {
    case ((mn, mx), (t, _)) => {
      val x = implicitly[ToDouble[T]].apply(t)
      val newMin = if (mn < x) mn else x
      val newMax = if (mx > x) mx else x
      (newMin, newMax)
    }
  }
  private[this] val width = max - min

  private[this] val bins: Array[Bin] = Array.fill(numBins)(new Bin)
  input.foreach{ case (x, y) => bins(index(x)) += (y) }

  /**
   * Simple, and fast prediction of the values generated by the histogram. The values is set
   * to Double.NaN if the input value is out of range.
   * @param t feature value
   * @return predicted value y = approx(x)
   */
  override def predict(t: T): Double = if (boundaries(t)) Double.NaN else bins(index(t)).y

  private def boundaries(t: T): Boolean = {
    val x = implicitly[ToDouble[T]].apply(t)
    x < min || x > max
  }

  final def mls(data: Array[(T, Double)]): Double =
    Math.sqrt(data./:(0.0) { case (s, (x, y)) => s + sqr(y - predict(x)) } / data.size)

  /**
   * Compute the absolute convergence criteria or rounding error
   */
  @inline
  final def relEps(eps: Double): Double = (max - min) * eps

  /**
   * Compute the index of the bin for the value x
   * @param x value for which the bin has to be retrieved
   * @return index of the bin
   */
  private def index(x: T): Int = {
    val idx = (bins.size*(implicitly[ToDouble[T]].apply(x) - min) / width).floor.toInt
    if (idx < 0) 0 else if (idx >= bins.size) bins.size - 1 else idx
  }

  @inline
  final def getBins: Array[Bin] = bins

  override def toString: String = bins.view.zipWithIndex
    .map { case (c, n) => s"$n, ${n + 1} - ${c.toString}" }.mkString("\n")

  def toString(size: Int): String = bins.take(size).view.zipWithIndex
    .map { case (c, n) => s"$n, ${n + 1} - ${c.toString}" }.mkString("\n")
}

/**
  * Singleton that defines the function approximation using an histogram
  * @author Patrick Nicolas
  * @since 0.99.2 Jan 11, 2017
  * @version 0.99.2
  * @note Scala for Machine Learning - Chapter 4 Unsupervised learning - Function approximation
  */
private[scalaml] object HistogramApprox {
  final val EPS = 1e-12
  final val RADIX = 8
  final def sqr(x: Double): Double = x * x

  def +(itBins1: Array[Bin], itBins2: Array[Bin]): Array[Bin] = {
    val histBins = new mutable.ArrayBuffer[Bin]
    itBins1.scanLeft(histBins)((newBins, bin) => newBins += bin)
    itBins2.scanLeft(histBins)((newBins, bin) => newBins += bin)
    histBins.toArray
  }
}

// ---------------------------------------------  EOF ------------------------------------------------------------

