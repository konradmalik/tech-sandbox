/**
 * Copyright (c) 2013-2017  Patrick Nicolas - Scala for Machine Learning - All rights reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License") you may not use this file
 * except in compliance with the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *
 * The source code in this file is provided by the author for the sole purpose of illustrating the
 * concepts and algorithms presented in "Scala for Machine Learning 2nd edition".
 * ISBN: 978-1-783355-874-2 Packt Publishing.
 *
 * Version 0.99.2
 */
package org.scalaml.validation

import org.scalaml.Predef.Context.ToDouble

import scala.util.{Random, Try}
import scala.language.implicitConversions
import org.scalaml.Predef._

/**
 * Class implementing a 1-Fold crossValidation
 *
 * @tparam T type of element of data to be processed
 * @constructor Create a one fold cross validation scheme to validate supervised
 * learning algorithm
 * @param xt Multi-dimensional time series of observations
 * @param expected expected (or labeled) class
 * @param ratio Ratio of training/validation
 * @author Patrick Nicolas
 * @since 0.98.3 (April 3, 2014)
 * @version 0.99.2
 * @see Scala for Machine Learning Chapter 2 ''Hello World!'' / Assessing a model /
 * K-Fold validation
 */
final private[scalaml] class OneFoldValidation[T](
    xt: Vector[Array[T]],
    expected: Vector[Int],
    ratio: Double
) {
  import OneFoldValidation._

  check(xt, expected, ratio)

  private[this] val trainValidate: (LabeledVector[T], LabeledVector[T]) = {
    val labeledData = xt.zip(expected)
    val trainingSize = (ratio * labeledData.size).floor.toInt

    // Compute the size of the validation set and adjust if necessary
    val valSz = labeledData.size - trainingSize
    val adjValSz =
      if (valSz < 2) 1
      else if (valSz >= labeledData.size) labeledData.size - 1
      else valSz

    // The random ordering of the dataset in the training set
    // and validation set are created by assigning a random value
    // to each labeled observations then sort them
    val ordLabeledData = labeledData.map((_, Random.nextDouble()))
      .sortWith(_._2 < _._2).unzip._1

    // Return the pair of training and validation sets.
    (ordLabeledData.takeRight(adjValSz), ordLabeledData.dropRight(adjValSz))
  }

  /**
   * Return the training set generated by the 1-fold cross validation
   *
   * @return training set of type ''Vector[(Array[T], Int)]''
   */
  final def trainingSet: LabeledVector[T] = trainValidate._1

  /**
   * Return the validation set generated by the 1-fold cross validation
   *
   * @return validation set of type ''Vector[(Array[T], Int)]''
   */
  final def validationSet: LabeledVector[T] = trainValidate._2
}

/**
 * Object companion to OneFoldXValidation that defines internal type
 * and constructors.
 *
 * @author Patrick Nicolas
 * @version 0.99.1
 * @see Scala for Machine Learning Chapter 2 Hello World! / Assessing a model /
 * K-Fold validation
 */
private[scalaml] object OneFoldValidation {
  type LabeledData[T] = (Array[T], Int)
  type LabeledType[T] = (LabeledData[T], Boolean)
  type LabeledVector[T] = Vector[(Array[T], Int)]

  /**
   * Constructor for OneFoldXValidation class using the observation, expected values and
   * the ratio of training set size and validation set size as arguments
   *
   * @tparam T type of element of data to be processed
   * @param xt Time series or data set of observed features of type Vector[Array[T]]
   * @param expected labels or expected values
   * @param ratio Ratio of the size of the training set over the size of the validation set
   * @note Exception are thrown by the inline constructor of the class
   */
  def apply[T](
    xt: VSeries[T],
    expected: Vector[Int],
    ratio: Double
  ): OneFoldValidation[T] = new OneFoldValidation[T](xt, expected, ratio)

  /**
   * Constructor for OneFoldXValidation class using the observation, expected values and
   * the ratio of training set size and validation set size as arguments
   *
   * @tparam T type of element of data to be processed
   * @param xt Time series or data set of observed features of type Array[Array[T]]
   * @param expected labels or expected values
   * @param ratio Ratio of the size of the training set over the size of the validation set
   * @note Exception are thrown by the inline constructor of the class
   */
  def apply[T](
    xt: Array[Array[T]],
    expected: Vector[Int],
    ratio: Double
  ): OneFoldValidation[T] = new OneFoldValidation[T](xt.toVector, expected, ratio)

  /**
   * Implicit conversion to Try
   */
  implicit def oneFoldValidation2Try[T](
    validationFold: OneFoldValidation[T]
  ): Try[OneFoldValidation[T]] = Try(validationFold)

  private def check[T](xt: Vector[Array[T]], expected: Vector[Int], ratio: Double): Unit = {
    require(
      xt.size == expected.size,
      s"OneFoldXValidation found  xt.size =${xt.size} !=  expected.size ${expected.size}"
    )
    require(
      ratio > 0.1 && ratio < 0.9,
      s"OneFoldXValidation found ratio = $ratio required 0.1 < ratio < 0.9"
    )
  }
}

// ----------------------  EOF --------------------------